# قسمت اول : مانیتورینگ
چرا مانیتورینگ؟
 مانیتورینگ یکی از ارکان اساسی در مدیریت و نگهداری سیستم‌های نرم‌افزاری و زیرساختی است. با پیچیده‌تر شدن سیستم‌های فناوری اطلاعات و افزایش وابستگی کسب‌وکارها به فناوری، نیاز به نظارت مستمر بر عملکرد، سلامت و رفتار سیستم‌ها بیش از پیش احساس می‌شود. اما چرا مانیتورینگ این‌قدر مهم است؟

## نیاز به مانیتورینگ

 **تشخیص مشکلات قبل از وقوع فاجعه**  
    <small>مانیتورینگ به تیم‌ها اجازه می‌دهد تا مشکلات احتمالی مانند قطعی سرویس، مصرف بیش از حد منابع یا خطاهای نرم‌افزاری را قبل از تأثیرگذاری بر کاربران شناسایی کنند.</small>

 **بهینه‌سازی عملکرد**  
    <small>با جمع‌آوری داده‌های عملکرد، تیم‌ها می‌توانند نقاط ضعف سیستم را شناسایی کرده و برای بهبود آن اقدام کنند.</small>

 **تضمین تجربه کاربری**  
    <small>در دنیای رقابتی امروز، ارائه خدمات پایدار و باکیفیت به کاربران از اهمیت بالایی برخوردار است. مانیتورینگ کمک می‌کند تا تجربه کاربری بهینه حفظ شود.</small>

 **پشتیبانی از تصمیم‌گیری داده‌محور**  
    <small>داده‌های مانیتورینگ به مدیران و مهندسان کمک می‌کند تا تصمیمات مبتنی بر داده‌های واقعی بگیرند.</small>

 **مدیریت پیچیدگی‌های معماری‌های مدرن**  
    <small>با ظهور معماری‌هایی مانند میکروسرویس‌ها، نیاز به نظارت بر اجزای متعدد و توزیع‌شده سیستم‌ها افزایش یافته است.</small>


## تاریخچه سیستم‌های مانیتورینگ
در دهه‌های گذشته، سیستم‌های مانیتورینگ از ابزارهای ساده‌ای مانند اسکریپت‌های دست‌نویس برای بررسی وضعیت سرورها (مانند بررسی آپ‌تایم یا مصرف CPU) شروع شدند. ابزارهایی مانند Nagios و Zabbix از اولین سیستم‌های مانیتورینگ مدرن بودند که امکان نظارت بر زیرساخت‌ها را فراهم می‌کردند. این ابزارها عمدتاً بر مدل‌های Pull-Based (کشیدن داده‌ها) یا Push-Based (ارسال داده‌ها) متکی بودند و هر یک مزایا و معایب خاص خود را داشتند.


## ارتباط مانیتورینگ با معماری‌های نرم‌افزاری
با ظهور معماری‌های مدرن مانند میکروسرویس‌ها، نیاز به مانیتورینگ پیشرفته‌تر شد. در معماری‌های مونولیتیک، یک سیستم مرکزی تمام اجزای نرم‌افزار را شامل می‌شد و مانیتورینگ آن ساده‌تر بود. اما در میکروسرویس‌ها:
- هر سرویس به‌صورت مستقل اجرا می‌شود و ممکن است در یک محیط توزیع‌شده باشد.
- تعداد نقاط پایانی (Endpoints) افزایش می‌یابد و هر سرویس ممکن است معیارهای خاص خود را داشته باشد.
- ابزارهای مانیتورینگ مانند پرومتئوس برای جمع‌آوری، ذخیره و تحلیل داده‌ها در چنین محیط‌هایی طراحی شده‌اند و با ابزارهای کشف سرویس (Service Discovery) مانند Kubernetes ادغام می‌شوند یعنی کوبرنیتیز میاد هرچی سرویس داری (به‌صورت داینامیک) رو بعنوان تارگت شناسایی میکنه و ادامه ماجرا رخ میده.


## معماری سیستم‌های Pull-based در مانیتورینگ
 فرض کنید یک معلم داریم و یک دانش آموز در حال دادن امتحان ... در معماری پول بیس معلم هر چند لحظه یکبار می آید داده‌هایی رو از وضعیت دانش آموزی که مدنظرش است(یکی یا چندتا) جمع میکند ( چجوری نشسته – تقلب میکنه یا نه – تموم کرده یا نه – نیاز به کمک داره یا ...) با فرض اینکه خود دانش آموز یا برگه امتحانیش این داده‌ها رو به صورتی که برای معلم خوانا هست داره تولید میکنه یعنی معلم میفهمد از شواهد و گزارش گیری از وضعیت دانش آموز تکمیل میشود.
 
سیستم‌های Pull-based یه مدل مانیتورینگ هستن که توش سیستم مانیتورینگ (مثل پرومتئوس) به‌صورت فعال می‌ره و داده‌ها (متریک‌ها) رو از سرویس‌ها یا سیستم‌هایی که می‌خواد مانیتور کنه، جمع‌آوری می‌کنه. این مدل در مقابل سیستم‌های Push-based قرار می‌گیره که توش سرویس‌ها خودشون داده‌ها رو به سیستم مانیتورینگ می‌فرستن. حالا بیایم معماری Pull-based رو به‌صورت جامع بررسی کنیم و اجزای اصلی و وظایفشون رو توضیح بدیم.


### اجزای اصلی معماری Pull-based
یه سیستم Pull-based معمولاً از چند جزء کلیدی تشکیل شده که هر کدوم نقش خاصی تو فرآیند جمع‌آوری، ذخیره، پردازش و استفاده از متریک‌ها دارن. این اجزا عبارتند از:

1. **سرور مانیتورینگ (Monitoring Server)**
2. **هدف‌ها (Targets)**
3. **اکسپورترها (Exporters)** (در صورت نیاز)
4. **پایگاه داده سری زمانی (Time Series Database - TSDB)**
5. **مکانیزم کشف سرویس (Service Discovery)** (اختیاری)
6. **سیستم هشداردهی (Alerting System)**
7. **رابط‌های کاربری و ابزارهای تجسم داده (Visualization and Querying Tools)**



## روال کلی کار تو معماری Pull-based
برای اینکه تصویر کامل بشه، بیایم روال کار رو قدم‌به‌قدم مرور کنیم:

1. **کشف هدف‌ها**: سرور مانیتورینگ از طریق فایل پیکربندی (با فرمت yaml) یا کشف سرویس، لیست هدف‌ها رو پیدا می‌کنه.
2. **جمع‌آوری متریک‌ها**: سرور به‌صورت دوره‌ای به انتهای HTTP هدف‌ها درخواست می‌فرسته و متریک‌ها رو scrape می‌کنه. اگه هدف به‌صورت بومی متریک تولید نکنه، اکسپورتر(exporter) این کار رو انجام می‌ده.
3. **اضافه کردن لیبل‌ها**: سرور لیبل‌های هدف (مثل instance و job) رو به متریک‌ها اضافه می‌کنه و همچنین اکسپورتر.
   
<div dir="rtl">

```plaintext
در اینجا ما دو نوع لیبل داریم، یک نوع آن لیبل‌هایی هستند که متریک اضافه می‌شوند از جانب اکسپورتر بر اساس اینکه تحلیل بر اساس آن‌ها می‌خواهد انجام شود، یعنی خود اکسپورتر در هدف یا وابسته به هدف لیبل‌هایی رو که می‌خواهد بر اساس آنها تحلیل یا دسته‌بندی صورت بگیره برای سری زمانی‌ای که قرار است تولید شود می‌سازد و نوع دوم که از جانب سرور (مثلا پرومتئوس) اضافه می‌شود برای اینکه مشخص شود کدام تارگت (سرویس) و نمونه این داده رو تحویل داده است.

```
</div>

4. **ذخیره‌سازی**: متریک‌ها به‌صورت سری‌های زمانی (نام متریک + لیبل‌ها + نمونه‌ها) تو TSDB ذخیره می‌شن.
5. **پردازش و هشداردهی**: سرور از داده‌های TSDB برای اجرای کوئری‌ها (مثل محاسبه نرخ) یا بررسی قوانین هشدار استفاده می‌کنه.
6. **تجسم و تحلیل**: داده‌ها از طریق رابط وب یا ابزارهای خارجی (مثل Grafana) نمایش داده می‌شن یا برای تحلیل‌های بیشتر کوئری می‌شن.
   

## مزایا و چالش‌های معماری Pull-based
### مزایا
- **کنترل مرکزی**: سرور مانیتورینگ کنترل کامل روی فرکانس و هدف‌های جمع‌آوری داره.
- **سادگی برای هدف‌ها**: هدف‌ها فقط نیاز به یه endpoint HTTP دارن، که پیاده‌سازیش ساده‌ست.
- **عیب‌یابی آسان**: می‌تونی مستقیم به endpoint هدف بری و متریک‌ها رو ببینی.
- **مقیاس‌پذیری با کشف سرویس**: تو محیط‌های پویا مثل Kubernetes، کشف سرویس خودکار خیلی کمک می‌کنه.

### چالش‌ها
- **بار روی سرور**: اگه تعداد هدف‌ها زیاد باشه، سرور باید بتونه همه رو به‌موقع scrape کنه.
- **مشکلات شبکه**: تو محیط‌هایی با فایروال یا NAT، دسترسی به endpointهای هدف ممکنه سخت باشه.
- **عدم پشتیبانی بومی از رویدادها**: برای داده‌های رویدادمحور (event-based)، مدل Push-based گاهی مناسب‌تره.



## سیستم‌های Push-Based
در مدل Push-Based، سرویس‌ها یا برنامه‌ها داده‌های خود را به سرور مانیتورینگ ارسال می‌کنند. ابزارهایی مانند Graphite از این مدل استفاده می‌کنند.

### مزایا
- مناسب برای محیط‌هایی که دسترسی مستقیم به سرویس‌ها دشوار است (مانند پشت NAT یا فایروال).
- انعطاف‌پذیری بیشتر در زمان‌بندی ارسال داده‌ها توسط سرویس‌ها.

### معایب
- نیاز به پیاده‌سازی منطق ارسال داده‌ها در هر سرویس.
- احتمال از دست رفتن داده‌ها در صورت قطعی شبکه.
- مدیریت پیچیده‌تر در محیط‌های بزرگ به دلیل پراکندگی داده‌ها.


### ۱. سرور مانیتورینگ (Monitoring Server)
**وظیفه**: قلب سیستم Pull-based هست و مسئول مدیریت کل فرآیند مانیتورینگ، از جمع‌آوری متریک‌ها تا ذخیره، پردازش، جستجو و نمایش آنها و تولید هشدارهاست .

**جزئیات**:
- سرور مانیتورینگ (مثل سرور پرومتئوس) به‌صورت دوره‌ای به هدف‌ها (targets) درخواست HTTP می‌فرسته تا متریک‌ها رو جمع‌آوری (scrape) کنه.
- فرکانس این جمع‌آوری‌ها (scrape interval) تو تنظیمات سرور مشخص می‌شه (مثلاً هر 15 ثانیه).
- سرور متریک‌ها رو از هدف‌ها می‌گیره، لیبل‌های اضافی (مثل instance و job) رو بهشون اضافه می‌کنه، و اونا رو تو پایگاه داده سری زمانی ذخیره می‌کنه.
- همچنین، سرور مسئول اجرای کوئری‌ها (مثل PromQL تو پرومتئوس) برای تحلیل داده‌ها و تولید هشدارها یا ارائه داده‌ها به ابزارهای تجسم (مثل Grafana) هست.

**ویژگی‌ها**:
- کنترل مرکزی داره: سرور تصمیم می‌گیره کی و از کجا متریک جمع کنه.
- می‌تونه چندین نمونه (instance Chaudhary) از خودش رو برای مقیاس‌پذیری اجرا کنه (مثلاً تو سازمان‌های بزرگ).
- معمولاً یه رابط وب ساده برای مشاهده متریک‌ها و کوئری کردن داده‌ها داره.

**مثال**: تو پرومتئوس، سرور پرومتئوس این نقش رو بازی می‌کنه و از طریق فایل پیکربندی با  فرمت yaml مثل فایل زیر هدف‌ها و تنظیمات scrape رو مدیریت می‌کنه.

`(prometheus.yml)`

```
# تنظیمات کلی پرومتئوس
global:
  scrape_interval: 15s # فاصله زمانی برای جمع‌آوری متریک‌ها (هر 15 ثانیه)
  scrape_timeout: 10s  # حداکثر زمان انتظار برای پاسخ از هدف‌ها
  evaluation_interval: 15s # فاصله زمانی برای ارزیابی قوانین (مثل هشدارها)

# تنظیمات مربوط به هشداردهی
alerting:
  alertmanagers:
    - static_configs:
        - targets:
            - alertmanager:9093 # آدرس Alertmanager

# قوانین هشدار (فایل‌های قوانین جداگانه)
rule_files:
  - "alert_rules.yml" # فایل حاوی قوانین هشدار

# تنظیمات جمع‌آوری متریک‌ها (scrape configs)
scrape_configs:
  # مانیتورینگ خود پرومتئوس
  - job_name: "prometheus"
    static_configs:
      - targets: ["localhost:9090"] # آدرس سرور پرومتئوس

  # مانیتورینگ یک سرور وب
  - job_name: "web_server"
    static_configs:
      - targets:
          - "web1.example.com:8080" # سرور وب اول
          - "web2.example.com:8080" # سرور وب دوم
        labels:
          env: "production" # افزودن لیبل محیط

  # مانیتورینگ یک دیتابیس MySQL با استفاده از اکسپورتر
  - job_name: "mysql"
    static_configs:
      - targets: ["mysql-exporter:9104"] # آدرس اکسپورتر MySQL
        labels:
          env: "production"

  # کشف سرویس برای محیط‌های پویا (مثل Kubernetes)
  - job_name: "kubernetes_services"
    kubernetes_sd_configs:
      - role: service # کشف سرویس‌های Kubernetes
    relabel_configs:
      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape]
        action: keep
        regex: true # فقط سرویس‌هایی که این annotation رو دارن مانیتور می‌شن
```




### ۲. هدف‌ها (Targets)
**وظیفه**: هدف‌ها سرویس‌ها، اپلیکیشن‌ها یا سیستم‌هایی هستن که متریک‌ها رو تولید می‌کنن و در دسترس سرور مانیتورینگ قرار می‌دن.

**جزئیات**:
- هر هدف یه انتهای HTTP (HTTP endpoint) فراهم می‌کنه (مثل /metrics) که متریک‌ها رو تو یه فرمت مشخص (معمولاً متنی) ارائه می‌ده.
- متریک‌ها معمولاً شامل یه نام (مثل http_requests_total)، لیبل‌ها (مثل status_code="200") و مقدار فعلی (مثل 1000) هستن.
- هدف‌ها می‌تونن اپلیکیشن‌های خودت باشن که با کتابخانه‌های کلاینت (مثل کتابخانه Go یا Python برای پرومتئوس) متریک‌ها رو تولید می‌کنن، یا سیستم‌های خارجی (مثل دیتابیس‌ها) که نیاز به اکسپورتر دارن.

**ویژگی‌ها**:
- هدف‌ها نیازی به ارسال فعال داده‌ها ندارن؛ فقط باید یه endpoint ساده فراهم کنن که سرور بتونه ازش داده بگیره.
- متریک‌ها توسط هدف با لیبل‌های خودشون تولید می‌شن (مثل تفکیک درخواست‌های HTTP بر اساس کد وضعیت یا متد).
- چون سیستم Pull-based هست، هدف‌ها می‌تونن خیلی ساده باشن و نیازی به منطق پیچیده برای ارسال داده ندارن.

**مثال**: یه سرور وب که متریک‌های http_requests_total رو با لیبل‌های status_code و method تو /metrics ارائه می‌ده.

---

### ۳. اکسپورترها (Exporters)
**وظیفه**: اکسپورترها واسطه‌هایی هستن که برای سیستم‌ها یا سرویس‌هایی که به‌صورت بومی متریک‌های قابل فهم برای سیستم مانیتورینگ (مثل فرمت پرومتئوس) تولید نمی‌کنن، متریک‌ها رو جمع‌آوری و به فرمت مناسب تبدیل می‌کنن.

**جزئیات**:
- اگه یه سیستم (مثل یه دیتابیس MySQL یا یه سرور لینوکس) خودش متریک‌ها رو به فرمت مورد نیاز ارائه نده، یه اکسپورتر کنارش اجرا می‌شه.
- اکسپورتر داده‌ها رو از سیستم هدف (مثل معیارهای عملکرد دیتابیس یا سیستم‌عامل) جمع می‌کنه و یه انتهای HTTP (مثل /metrics) فراهم می‌کنه که سرور مانیتورینگ بتونه ازش scrape کنه.
- اکسپورترها معمولاً یه پروسه جداگونه هستن که کنار سیستم اصلی اجرا می‌شن.
- در دنیای کنونی تقریبا همه سرویس های معروف مثل nginx ، mysql و ... خودشون اکسپورتر های خاصی دارند که  به صورت متن باز در اختیار برنامه نویسان هستش.

**ویژگی‌ها**:
- باعث می‌شن سیستم‌های غیربومی هم بتونن با سیستم مانیتورینگ Pull-based کار کنن.
- اکسپورترها می‌تونن لیبل‌های اضافی به متریک‌ها اضافه کنن (مثل تفکیک معیارها بر اساس نوع دیتابیس یا هاست).

**مثال**: تو پرومتئوس، اکسپورتر Node Exporter برای جمع‌آوری معیارهای سیستم‌عامل (مثل CPU، حافظه، دیسک) یا MySQL Exporter برای دیتابیس MySQL استفاده می‌شه.

---

### ۴. پایگاه داده سری زمانی (Time Series Database - TSDB)

دیتابیس سری های زمانی یا Time-Series Database یک پایگاه داده تخصصی است که برای ذخیره و مدیریت داده‌های سری زمانی طراحی شده است. سری‌های زمانی مجموعه‌ای از داده‌ها هستند که به‌صورت متوالی در طول زمان ثبت می‌شوند و هر داده شامل یک مقدار عددی و یک برچسب زمانی (Timestamp) است. TSDB در پرومتئوس به‌صورت داخلی پیاده‌سازی شده و برای ذخیره معیارهای (Metrics) جمع‌آوری‌شده از سرویس‌ها و سیستم‌ها استفاده می‌شود.


**جزئیات**:
- دیتابیس سری های زمانی داده‌ها رو به‌صورت سری‌های زمانی ذخیره می‌کنه. هر سری زمانی یه شناسه یکتا داره (ترکیب نام متریک و لیبل‌ها) و شامل یه لیست از نمونه‌ها (تایم‌استمپ + مقدار) هست.
- تو هر scrape، سرور مانیتورینگ متریک‌ها رو از هدف‌ها می‌گیره و به‌عنوان نمونه‌های جدید به سری‌های زمانی مربوطه تو TSDB اضافه می‌کنه.
- داده‌ها بدون پردازش اولیه ذخیره می‌شن (یعنی همون مقادیر خام با تایم‌استمپ). پردازش‌ها (مثل محاسبه نرخ یا تجمیع) موقع کوئری کردن انجام می‌شن.
- دیتابیس سری های زمانی معمولاً روی دیسک محلی سرور مانیتورینگ ذخیره می‌شه، ولی می‌تونه به سیستم‌های ذخیره‌سازی خارجی هم متصل بشه.


**ویژگی‌ها**:
- بهینه برای ذخیره حجم زیادی از سری‌های زمانی با فشرده‌سازی خوب.
- امکان کوئری سریع برای تحلیل‌های زمانی (مثل محاسبه نرخ تغییرات تو 5 دقیقه گذشته).
- یه دوره نگهداری (retention period) داره که مشخص می‌کنه داده‌ها تا چه مدت نگه داشته می‌شن (مثلاً 15 روز).

  
### ویژگی‌های TSDB در پرومتئوس
1. **ذخیره‌سازی سری‌های زمانی**: هر سری زمانی شامل یک نام معیار (Metric Name)، مجموعه‌ای از برچسب‌ها (Labels) و یک جریان از نمونه‌ها (Samples) است.
2. **فشرده‌سازی داده‌ها**: TSDB پرومتئوس از الگوریتم‌های فشرده‌سازی پیشرفته‌ای مانند Delta Encoding و Double Delta Encoding استفاده می‌کند تا فضای ذخیره‌سازی را بهینه کند.
3. **عملکرد بالا**: طراحی شده برای خواندن و نوشتن سریع داده‌ها، حتی در محیط‌هایی با حجم بالای معیارها.
4. **ذخیره‌سازی محلی**: به‌صورت پیش‌فرض، داده‌ها روی دیسک محلی ذخیره می‌شوند، اما امکان ارسال به ذخیره‌سازی راه دور (Remote Storage) نیز وجود دارد.
5. **پشتیبانی از پرس‌وجو**: از طریق زبان PromQL، کاربران می‌توانند داده‌های ذخیره‌شده را تحلیل و پرس‌وجو کنند.



### دو سؤال مهم اینجاست:
- **هر نمونه (sample) چطور مدل‌سازی می‌شه و چه مقادیری می‌تونه داشته باشه؟**
- **چطور می‌تونیم سری‌های زمانی مختلف رو از هم جدا کنیم و شناسایی کنیم؟**

#### شناسه سری زمانی
هر سری زمانی با یک نام معیار (metric name) و مجموعه‌ای از لیبل‌ها (labels) به‌صورت یکتا شناسایی می‌شه.

- **نام معیار**: مشخص می‌کنه که چه چیزی رو داری اندازه‌گیری می‌کنی، مثلاً تعداد درخواست‌های HTTP که یک سرور از زمان شروعش پردازش کرده، دمای یک دستگاه، یا میزان استفاده از حافظه.
- **لیبل‌ها**: جفت‌های کلید-مقدار (key-value pairs) هستن که بهت اجازه می‌دن یک معیار رو به چندین سری زمانی تقسیم کنی. مثلاً می‌تونی تعداد درخواست‌های HTTP رو بر اساس متد HTTP (مثل GET یا POST) یا کد وضعیت (مثل 200 یا 500) تقسیم‌بندی کنی.
- پرومتئوس به‌صورت خودکار لیبل‌های هدف (target labels) رو اضافه می‌کنه تا مشخص کنه هر سری زمانی از کدوم هدف اومده. اما خود هدف هم می‌تونه لیبل‌های اضافی اضافه کنه، مثلاً یک سرور HTTP می‌تونه تعداد درخواست‌ها رو بر اساس متد و کد وضعیت تفکیک کنه.

#### نمونه‌ها (Samples)
- هر نمونه در یک سری زمانی شامل یک تایم‌استمپ (timestamp) و یک مقدار (value) هست.
- تایم‌استمپ معمولاً زمان جمع‌آوری معیاره و به‌صورت یک عدد صحیح 64 بیتی (بر حسب میلی‌ثانیه) ذخیره می‌شه.
- مقدار نمونه می‌تونه هر عدد اعشاری 64 بیتی (floating-point) باشه.
- **نکته**: در آینده‌ای نزدیک (طبق ترنسکریپت)، پرومتئوس قراره یک نوع داده جدید به نام هیستوگرام بومی (native histogram) رو پشتیبانی کنه، که در اون یک نمونه می‌تونه به‌جای یک عدد ساده، یک هیستوگرام کامل باشه. ولی فعلاً این ویژگی به‌صورت رسمی در پرومتئوس نیست.

#### ساختار یک سری زمانی
یک سری زمانی در پرومتئوس به‌صورت زیر تعریف می‌شود:

```{metric_name}{label1="value1", label2="value2", ...} -> [(timestamp1, value1), (timestamp2, value2), ...]```

### مثال واقعی از یک سری زمانی
فرض کنید یک وب‌سرور Nginx دارید که تعداد درخواست‌های HTTP دریافتی را مانیتور می‌کنید. پرومتئوس معیاری به نام `http_requests_total` را از این سرور جمع‌آوری می‌کند. این معیار تعداد کل درخواست‌های HTTP دریافت‌شده توسط سرور را نشان می‌دهد و با برچسب‌هایی مانند `method` (متد HTTP مانند GET یا POST) و `status_code` (کد وضعیت مانند 200 یا 500) تفکیک می‌شود.

#### مثال سری زمانی
**نام معیار**: `http_requests_total`

**برچسب‌ها**:
```
- `method="GET"`
- `status_code="200"`
- `instance="webserver1.example.com:80"`
- `job="nginx"`
```

سری زمانی به‌صورت زیر خواهد بود:

```http_requests_total{method="GET", status_code="200", instance="webserver1.example.com:80", job="nginx"}```


این سری زمانی شامل جریانی از نمونه‌ها (Samples) است که هر نمونه یک مقدار عددی (تعداد درخواست‌ها) و یک برچسب زمانی دارد.

**برای مثال**:

```[(1623678900000, 100), (1623678960000, 150), (1623679020000, 200)]```

- **برچسب زمانی (Timestamp)**: به‌صورت یک عدد 64 بیتی (میلی‌ثانیه از زمان Unix Epoch). برای مثال، 1623678900000 معادل 14 ژوئن 2021، ساعت 12:15:00 UTC است.
- **مقدار (Value)**: تعداد کل درخواست‌های HTTP با متد GET و کد وضعیت 200 تا آن لحظه.


#### داده‌ها در فرمت متنی پرومتئوس
وقتی پرومتئوس از یک نقطه پایانی (Endpoint) مانند `/metrics` داده‌ها را جمع‌آوری می‌کند، این داده‌ها به‌صورت متنی ارائه می‌شوند. برای مثال، خروجی زیر ممکن است از سرور Nginx دریافت شود:
```
HELP http_requests_total The total number of HTTP requests
TYPE http_requests_total counter
http_requests_total{method="GET", status_code="200", instance="webserver1.example.com:80", job="nginx"} 200
http_requests_total{method="POST", status_code="200", instance="webserver1.example.com:80", job="nginx"} 50
http_requests_total{method="GET", status_code="500", instance="webserver1.example.com:80", job="nginx"} 5
```


- **# HELP**: توضیحی در مورد معیار.
- **# TYPE**: نوع معیار (در اینجا counter که نشان‌دهنده یک مقدار افزایشی است).
- هر خط نشان‌دهنده مقدار فعلی یک سری زمانی است که در زمان جمع‌آوری (Scrape) ثبت شده است.


---

### ۵. مکانیزم کشف سرویس (Service Discovery)
**وظیفه**: پیدا کردن و به‌روزرسانی خودکار لیست هدف‌هایی که باید مانیتور بشن.

**جزئیات**:
- تو محیط‌های ساده، هدف‌ها می‌تونن به‌صورت دستی تو فایل پیکربندی سرور تعریف بشن (مثل لیست استاتیک تو prometheus.yml).
- اما تو محیط‌های پویا (مثل Kubernetes که سرویس‌ها مدام اضافه یا حذف می‌شن)، کشف سرویس خودکار لازمه. این مکانیزم به سرور مانیتورینگ می‌گه کدوم هدف‌ها رو باید scrape کنه.
- روش‌های کشف سرویس شامل DNS، API‌های پلتفرم‌های ابری (مثل Kubernetes API)، Consul، یا حتی فایل‌های سفارشی هستن.

**ویژگی‌ها**:
- باعث می‌شه سیستم تو محیط‌های دینامیک مقیاس‌پذیر باشه.
- لیبل‌های اضافی (مثل metadata از Kubernetes) رو به هدف‌ها اضافه می‌کنه تا متریک‌ها دقیق‌تر شناسایی بشن.

**مثال**: تو پرومتئوس، کشف سرویس می‌تونه از Kubernetes API استفاده کنه تا podها یا سرویس‌ها رو به‌صورت خودکار به‌عنوان هدف پیدا کنه.

---

### ۶. سیستم هشداردهی (Alerting System)
**وظیفه**: شناسایی مشکلات تو سیستم‌های مانیتور شده و ارسال هشدار به کاربرها یا سیستم‌های مدیریت.

**جزئیات**:
- سیستم هشداردهی از داده‌های TSDB استفاده می‌کنه و با کوئری‌های از پیش تعریف‌شده (مثل PromQL) شرایط مشکل‌ساز (مثل نرخ خطای بالا) رو شناسایی می‌کنه.
- هشدارها معمولاً از طریق یه کامپوننت جداگونه (مثل Alertmanager تو پرومتئوس) مدیریت، جمع‌بندی و به مقصدهایی مثل ایمیل، Slack یا PagerDuty یا webhook ارسال می‌شن.
- قوانین هشدار (alerting rules) شامل یه کوئری و متادیتا (مثل زمان تحمل یا توضیحات) هستن.

**ویژگی‌ها**:
- امکان تعریف هشدارهای پیچیده با استفاده از کوئری‌های سری زمانی.
- قابلیت گروه‌بندی و فیلتر کردن هشدارها برای کاهش نویز.

**مثال**: تو پرومتئوس، Alertmanager هشدارها رو بر اساس قوانین PromQL مدیریت می‌کنه. مثلاً شرط زیر که در صورت وقوع و رسیدن به مرحله ی Firing یه هشدار برای خطاهای 500 می‌فرسته.

```rate(http_requests_total{status_code="500"}[5m]) > 0.1```

---

### ۷. رابط‌های کاربری و ابزارهای تجسم داده (Visualization and Querying Tools)
**وظیفه**: ارائه راهی برای مشاهده، تحلیل و کوئری کردن داده‌های ذخیره‌شده تو TSDB.

**جزئیات**:
- سرور مانیتورینگ معمولاً یه رابط وب ساده برای کوئری کردن داده‌ها و مشاهده متریک‌ها داره.
- ابزارهای خارجی مثل Grafana می‌تونن به TSDB متصل بشن و داشبوردهای گرافیکی برای تجسم داده‌ها بسازن.
- زبان‌های کوئری (مثل PromQL) به کاربرا اجازه می‌دن تحلیل‌های پیچیده (مثل محاسبه نرخ یا تجمیع داده‌ها) انجام بدن.

**ویژگی‌ها**:
- امکان ساخت داشبوردهای سفارشی برای نمایش معیارهای کلیدی.
- پشتیبانی از کوئری‌های ad-hoc برای دیباگ کردن یا تحلیل‌های موقت.

**مثال**: تو پرومتئوس، می‌تونی از رابط وب خودش برای کوئری‌های PromQL استفاده کنی یا داده‌ها رو به Grafana بفرستی برای ساخت داشبورد.




## پرومتئوس چیست؟
پرومتئوس یک سیستم مانیتورینگ و هشداردهی مبتنی بر معیارها (Metrics-Based) است که برای نظارت بر سیستم‌ها و سرویس‌های نرم‌افزاری طراحی شده است. این ابزار توسط SoundCloud در سال ۲۰۱۲ توسعه یافت و در سال ۲۰۱۶ به بنیاد Cloud Native Computing Foundation (CNCF) پیوست. پرومتئوس به دلیل انعطاف‌پذیری، مقیاس‌پذیری و ادغام قوی با اکوسیستم‌های مدرن مانند Kubernetes به یکی از محبوب‌ترین ابزارهای مانیتورینگ تبدیل شده است.

### چرا پرومتئوس بوجود آمد؟
پرومتئوس برای پاسخ به نیازهای مانیتورینگ در محیط‌های پویا و پیچیده طراحی شد. در آن زمان، ابزارهای موجود مانند Nagios برای محیط‌های مدرن کافی نبودند، زیرا:
- محیط‌های ابری و کانتینریزه‌شده نیاز به کشف خودکار سرویس‌ها داشتند.
- نیاز به ذخیره و تحلیل داده‌های زمانی (Time-Series) با حجم بالا و در مقیاس بزرگ بود.
- ابزارهای قدیمی در مدیریت داده‌های چندبعدی و پرس‌وجوهای پیچیده ضعیف عمل می‌کردند.

پرومتئوس این مشکلات را با ارائه یک مدل داده چندبعدی، زبان پرس‌وجوی قدرتمند (PromQL) و معماری Pull-Based حل کرد.




## معماری پرومتئوس
معماری پرومتئوس شامل اجزای اصلی زیر است:

### سرور پرومتئوس
- قلب سیستم که مسئول جمع‌آوری (Scraping)، ذخیره و پردازش معیارها است.
- داده‌ها را در یک پایگاه داده زمانی (TSDB) ذخیره می‌کند.

### کلاینت‌های پرومتئوس
- کتابخانه‌هایی برای زبان‌های برنامه‌نویسی مختلف (مانند Go، Python، Java) که به برنامه‌ها اجازه می‌دهند معیارهای خود را در قالب پرومتئوس ارائه کنند.

### اکسپورترها (Exporters)
- برای سیستم‌هایی که به‌صورت بومی از پرومتئوس پشتیبانی نمی‌کنند (مانند دیتابیس‌ها یا سرورهای لینوکس)، اکسپورترها معیارها را به فرمت قابل‌فهم برای پرومتئوس تبدیل می‌کنند. مثلا وقتی شما با PSQL داری کار میکنی .. خروجی یا نتیجه کوئری‌ای که زدی را بررسی میکنی میبینی برای پرومتئوس و سیستم‌های مانیتورینگ قابل فهم نیست و توانایی تولید سری زمانی رو از اون داده و نتیجه ندارد ... پس اگر خودش به زبون سیستم مانیتورینگ حرف نزنه نیاز به یه نفر داره اون حرف زدن با سرور رو بهش یاد بده و بعد دوباره خودش با سرور حرف بزنه یا کلا از اول سرور با یک هم‌زبان حرف بزنه!!!

### سیستم مدیریت هشدار ها (Alertmanager)
- کامپوننتی برای مدیریت هشدارها، تجمیع و ارسال آن‌ها به مقاصد مختلف (مانند ایمیل، Slack یا PagerDuty). شاید حد نهایی و غایی سیستم مانیتورینگ این است که به حفظ و پایداری سیستم از طریق گزارشات و بررسی وضعیت بپردازد ... قطعا قرار است اگر شرایط ویژه و خاصی رخ داد ما بعنوان مدیر سیستم یا صاحب کسب و کار متوجه شویم پس alert manager تمام کننده این ساختمان است.

### رابط کاربری و داشبورد
- پرومتئوس یک رابط کاربری وب ساده دارد، اما معمولاً با ابزارهایی مانند Grafana برای داشبوردهای پیشرفته‌تر ادغام می‌شود.

### کشف سرویس (Service Discovery)
- امکان کشف خودکار سرویس‌ها از طریق مکانیزم‌هایی مانند DNS، Kubernetes یا Consul.




## زبان پرس‌وجو (PromQL)
زبان کوئری محور PromQL، زبان پرس‌وجوی پرومتئوس است که امکان تحلیل پیچیده داده‌های زمانی را فراهم می‌کند. این زبان برای محاسبات مبتنی بر سری‌های زمانی طراحی شده و قابلیت‌هایی مانند:

- محاسبه نرخ تغییرات (Rate).
- تجمیع داده‌ها (Aggregation) بر اساس برچسب‌ها.
- فیلتر کردن سری‌های زمانی بر اساس شرایط خاص.



## نقش پرومتئوس در DevOps
پرومتئوس به‌عنوان یکی از ابزارهای کلیدی در فرهنگ DevOps شناخته می‌شود، زیرا:

### مانیتورینگ و مشاهده‌پذیری (Observability)
- پرومتئوس با ارائه معیارهای دقیق و داشبوردهای بصری، به تیم‌های DevOps کمک می‌کند تا رفتار سیستم‌ها را درک کنند.

### هشداردهی (Alerting)
- با استفاده از Alertmanager، تیم‌ها می‌توانند هشدارهای خودکار برای مشکلات احتمالی تنظیم کنند.

### ادغام با CI/CD
- پرومتئوس به تیم‌ها کمک می‌کند تا عملکرد برنامه‌ها را در طول فرآیندهای CI/CD مانیتور کنند.

### پشتیبانی از معماری‌های ابری
- ادغام با Kubernetes و دیگر پلتفرم‌های ابری، پرومتئوس را به ابزاری ایده‌آل برای محیط‌های مدرن تبدیل کرده است.



## ابزارهای پرومتئوس
پرومتئوس اکوسیستم گسترده‌ای از ابزارها و ادغام‌ها دارد:
- **کتابخانه‌های کلاینت**: برای زبان‌هایی مانند Go، Python، Java و غیره.
- **اکسپورترها**: مانند Node Exporter (برای معیارهای سیستم)، MySQL Exporter، و غیره.
```
- **Grafana**: برای ایجاد داشبوردهای بصری.
- **PromLens**: برای ساخت پرس‌وجوهای پیچیده PromQL.
- **Alertmanager**: برای مدیریت و ارسال هشدارها.
```

## نتیجه‌گیری
پرومتئوس به‌عنوان یک ابزار قدرتمند و انعطاف‌پذیر، نیازهای مانیتورینگ در محیط‌های مدرن را به‌خوبی برآورده می‌کند. با مدل داده چندبعدی، زبان پرس‌وجوی PromQL و ادغام قوی با اکوسیستم‌های ابری، پرومتئوس به یکی از ستون‌های اصلی مشاهده‌پذیری در DevOps تبدیل شده است. این مقاله به‌عنوان پایه‌ای برای دوره آموزشی عمیق در مورد پرومتئوس می‌تواند مورد استفاده قرار گیرد و با گسترش موضوعات در جلسات بعدی، دانش جامعی در این زمینه ارائه دهد.

---

