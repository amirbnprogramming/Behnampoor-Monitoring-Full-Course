# قسمت سوم : پرومتئوس ، انواع متریک ها

در این بخش از آموزش پرومتئوس، به بررسی عمیق چهار نوع متریک اصلی در پرومتئوس می‌پردازیم: **Gauge**، **Counter**، **Summary** و **Histogram**. هر یک از این متریک‌ها برای موقعیت‌های خاصی استفاده می‌شوند و درک نحوه استفاده از آن‌ها در برنامه‌نویسی و کوئری‌نویسی با PromQL بسیار مهم است. در ادامه، هر نوع متریک را به‌صورت جداگانه بررسی می‌کنیم، ویژگی‌های آن‌ها را توضیح می‌دهیم و نحوه استفاده صحیح از آن‌ها را شرح می‌دهیم.

## 1. متریک‌های Gauge

### تعریف و کاربرد
متریک‌های **Gauge** ساده‌ترین نوع متریک در پرومتئوس هستند. این متریک‌ها برای اندازه‌گیری مقادیر عددی که به‌طور طبیعی می‌توانند **افزایش یا کاهش** یابند، استفاده می‌شوند. این نوع متریک برای نمایش وضعیت فعلی یک سیستم یا برنامه مناسب است، مانند:
- میزان استفاده از حافظه (Memory Usage)
- طول صف (Queue Length)
- فضای دیسک (Disk Space)
- دما (Temperature)

به‌طور کلی، متریک‌های Gauge مقادیری را نشان می‌دهند که در برنامه یا دنیای واقعی وجود دارند و شما صرفاً می‌خواهید آن‌ها را به‌عنوان یک متریک پرومتئوس نمایش دهید.

### روش‌های به‌روزرسانی در برنامه‌نویسی
هنگام استفاده از متریک‌های Gauge در برنامه، کتابخانه‌های کلاینت پرومتئوس روش‌های زیر را ارائه می‌دهند:
- ** تابع Set()**: تنظیم مقدار Gauge به یک مقدار دلخواه.
- ** توابع Inc() و Dec()**: افزایش یا کاهش مقدار فعلی به‌صورت نسبی (به میزان یک یا مقدار مشخص).
- **روش‌های کمکی برای ذخیره زمان**: برخی کتابخانه‌ها امکان ذخیره زمان به‌صورت Unix Timestamp را فراهم می‌کنند. این قابلیت برای ثبت زمان وقوع رویدادهایی مانند زمان بوت سیستم، شروع فرآیند یا آخرین اجرای یک کار دسته‌ای (Batch Job) مفید است.

### فرمت نمایش (Exposition Format)
در فرمت نمایش متریک‌ها، یک Gauge به‌صورت یک سری زمانی (Time Series) نمایش داده می‌شود. اگر برچسب‌های اضافی (Labels) استفاده نشود، تنها یک سری زمانی ساده خواهید داشت.

### کوئری‌نویسی با PromQL
ارزش فعلی یک Gauge به‌خودی‌خود معنادار است و معمولاً می‌توانید آن را مستقیماً در نمودارها نمایش دهید. بااین‌حال، می‌توانید عملیات‌های تجمیعی (Aggregations) یا سایر عملیات را روی آن اعمال کنید. برای مثال:
- برای Gauge‌هایی که حاوی زمان (Timestamp) هستند، می‌توانید با استفاده از تابع `time()` در PromQL، اختلاف زمانی بین مقدار فعلی و زمان ثبت‌شده را محاسبه کنید تا مدت زمان گذشته از یک رویداد را به دست آورید.

### مثال عملی
فرض کنید در یک برنامه پایتون، میزان استفاده از حافظه (در مگابایت) را ردیابی می‌کنیم:
```python
from prometheus_client import Gauge
import psutil

memory_usage = Gauge('app_memory_usage_mb', 'Memory usage of the application in MB')

def update_memory_usage():
    memory = psutil.virtual_memory()
    memory_usage.set(memory.used / 1024 / 1024)  # تبدیل به مگابایت
```

**تحلیل مثال**:
- متریک `app_memory_usage_mb` مقدار فعلی استفاده از حافظه را نشان می‌دهد.
- با استفاده از `set()`، مقدار حافظه به‌صورت دوره‌ای به‌روزرسانی می‌شود.
- در PromQL، می‌توان این متریک را مستقیماً با `app_memory_usage_mb` کوئری کرد و در داشبورد Grafana نمایش داد.
- اگر بخواهیم حداکثر استفاده از حافظه در 5 دقیقه گذشته را ببینیم، از کوئری زیر استفاده می‌کنیم:
  ```promql
  max_over_time(app_memory_usage_mb[5m])
  ```
## 2. متریک‌های Counter

### تعریف و کاربرد
متریک‌های **Counter** برای شمارش تجمعی رویدادها یا مقادیر در طول زمان استفاده می‌شوند. این متریک‌ها **فقط می‌توانند افزایش یابند** و هرگز کاهش نمی‌یابند، مگر در مواردی که فرآیند ردیابی متریک (مانند سرور یا برنامه) ری‌استارت شود. مثال‌هایی از کاربرد Counter:
- تعداد کل درخواست‌های HTTP دریافت‌شده.
- مجموع زمان صرف‌شده (به ثانیه) برای پردازش درخواست‌ها.

### ری‌استارت شدن متریک کانتر یا ( Counter reset )
اگر فرآیند ردیابی متریک ری‌استارت شود، مقدار Counter به صفر ریست می‌شود. این وضعیت به‌عنوان **Counter Reset** شناخته می‌شود و PromQL می‌تواند به‌صورت خودکار این ریست‌ها را مدیریت کند.

### روش‌های به‌روزرسانی در برنامه‌نویسی
برای به‌روزرسانی متریک‌های Counter، دو روش اصلی وجود دارد:
- **تابع Inc()**: افزایش مقدار Counter به میزان یک واحد. این روش برای ثبت وقوع یک رویداد (مانند یک درخواست HTTP) استفاده می‌شود.
- ** تابع Add()**: افزایش مقدار Counter به میزان دلخواه (عدد صحیح یا اعشاری). این روش برای مواردی مانند ثبت زمان پردازش درخواست‌ها (که ممکن است اعشاری باشد) یا شمارش دسته‌ای از رویدادها مناسب است.

برخلاف Gauge، متریک‌های Counter هیچ روشی برای کاهش مقدار یا تنظیم مقدار مطلق ندارند، زیرا این کار با مفهوم Counter سازگار نیست.

### فرمت نمایش (Exposition Format)
در فرمت نمایش، Counterها شبیه به Gaugeها هستند، با این تفاوت که متادیتای اختیاری نوع متریک را به‌عنوان Counter مشخص می‌کند.

### کوئری‌نویسی با PromQL
مقدار مطلق یک Counter معمولاً اطلاعات مفیدی ارائه نمی‌دهد، زیرا این مقدار به زمان شروع Counter (که ممکن است یک سال یا یک دقیقه پیش باشد) وابسته است. به‌جای آن، باید **نرخ افزایش** Counter را در یک بازه زمانی خاص بررسی کنید. PromQL توابعی مانند `rate()`، `irate()` و `increase()` را برای این منظور ارائه می‌دهد:
- این توابع نرخ افزایش Counter را در یک بازه زمانی مشخص محاسبه می‌کنند.
- این توابع به‌صورت خودکار ریست‌های Counter را مدیریت می‌کنند و در صورت کاهش مقدار در بازه زمانی مشخص، آن را به‌عنوان ریست شناسایی کرده و اصلاح می‌کنند.

### مثال عملی
فرض کنید تعداد درخواست‌های HTTP را در یک سرور Flask ردیابی می‌کنیم:
```python
from prometheus_client import Counter
from flask import Flask

app = Flask(__name__)
http_requests_total = Counter('http_requests_total', 'Total HTTP requests')

@app.route('/')
def index():
    http_requests_total.inc()  # افزایش با هر درخواست
    return 'Hello, World!'
```

**تحلیل مثال**:
- متریک `http_requests_total` تعداد کل درخواست‌ها را شمارش می‌کند.
- با هر درخواست، `inc()` فراخوانی می‌شود.
- برای محاسبه نرخ درخواست‌ها در ثانیه در 5 دقیقه گذشته، از کوئری زیر استفاده می‌کنیم:
  ```promql
  rate(http_requests_total[5m])
  ```
- این کوئری نرخ متوسط درخواست‌ها در ثانیه را نشان می‌دهد و ریست‌های Counter را به‌صورت خودکار مدیریت می‌کند.

## 3. متریک‌های Summary

### تعریف و کاربرد
متریک‌های **Summary** برای ردیابی توزیع مقادیر عددی (مانند تأخیر درخواست‌ها) به‌صورت صدک‌ها (Percentiles) یا کوانتایل‌ها (Quantiles) استفاده می‌شوند. این متریک‌ها برای تحلیل آماری توزیع داده‌ها مناسب هستند.

### کوانتایل و صدک چیه؟
به زبان ساده، صدک (Percentile) یا کوانتایل (Quantile) یه جورایی بهت می‌گه که یه درصد خاص از داده‌هات کجا قرار دارن. مثلاً فرض کن تو یه کلاس 100 تا دانش‌آموز دارن امتحان می‌دن:

- **صدک 50 (یا کوانتایل 0.5)**: نمره‌ای که نصف دانش‌آموزا (50 نفر) نمره‌شون کمتر یا مساوی اون باشه.
- **صدک 90 (یا کوانتایل 0.9)**: نمره‌ای که 90 درصد دانش‌آموزا (90 نفر) نمره‌شون کمتر یا مساوی اون باشه. یعنی فقط 10 نفر نمره بهتری دارن.
- 
این مفاهیم تو پرومتئوس برای تحلیل داده‌هایی مثل تأخیر درخواست‌های یه وبسایت استفاده می‌شن. مثلاً صدک 90 تأخیر بهت می‌گه 90 درصد درخواست‌ها چقدر طول کشیدن یا کمتر.

### ایجاد و تنظیم Summary
هنگام ایجاد یک Summary، باید کوانتایل‌های موردنظر (مانند 0.5، 0.9، 0.99) و حاشیه خطا را مشخص کنید. سپس، با استفاده از متد **Observe()**، مقادیر خاصی (مانند تأخیر یک درخواست HTTP) را ثبت می‌کنید. برای مثال:
- اگر یک درخواست HTTP 2.3 ثانیه طول کشیده باشد، با فراخوانی `Observe(2.3)` این مقدار ثبت می‌شود.

قسمت Summary به‌طور خودکار کوانتایل‌های خروجی را با استفاده از الگوریتم‌های جریانی (Streaming Algorithms) به‌روزرسانی می‌کند.

### فرمت نمایش (Exposition Format)
در فرمت نمایش، یک Summary به مجموعه‌ای از سری‌های زمانی تبدیل می‌شود:
- یک سری زمانی برای هر کوانتایل محاسبه‌شده.
- سری زمانی `_count` برای تعداد کل مشاهدات.
- سری زمانی `_sum` برای مجموع مقادیر مشاهده‌شده.

برای مثال، در مورد تأخیر درخواست‌ها، `_count` تعداد کل درخواست‌ها و `_sum` مجموع زمان صرف‌شده برای پردازش درخواست‌ها را نشان می‌دهد.

### کوئری‌نویسی با PromQL
قسمت Summary را می‌توان به‌عنوان مجموعه‌ای از متریک‌های Gauge و Counter در نظر گرفت. در PromQL، می‌توانید از سری‌های زمانی جداگانه مانند Gauge یا Counter استفاده کنید. اما توجه کنید:

- **اجتناب از تجمیع کوانتایل‌ها**: تجمیع کوانتایل‌ها (مانند میانگین‌گیری از صدک 90 در چندین نمونه سرویس) از نظر آماری معتبر نیست. بنابراین، Summary برای مواردی مناسب است که نیازی به تجمیع در ابعاد مختلف (مانند نمونه‌های سرویس) ندارید.
- اگر نیاز به تجمیع دارید، باید از متریک‌های **Histogram** استفاده کنید.

### مثال عملی
ردیابی (ثبت) تأخیر درخواست‌های ارسال شده با start time در یک برنامه و به مشاهده ی متریک سامری رساندن توسط observe :
```python
from prometheus_client import Summary
from flask import Flask
import time

app = Flask(__name__)
request_latency = Summary('http_request_latency_seconds', 'HTTP request latency', quantiles=[0.5, 0.9, 0.99])

@app.route('/process')
def process():
    start = time.time()
    # شبیه‌سازی پردازش
    time.sleep(0.1)
    request_latency.observe(time.time() - start)
    return 'Processed'
```

**تحلیل مثال**:
- متریک `http_request_latency_seconds` تأخیر هر درخواست را ثبت می‌کند.
- کوانتایل‌های 50، 90 و 99 درصد محاسبه می‌شوند.
- برای مشاهده کوانتایل 90 درصد، می‌توان از کوئری زیر استفاده کرد یعنی 90 درصد درخواست ها چقدر تاخیر داشتند :
  ```promql
  http_request_latency_seconds{quantile="0.9"}
  ```
- برای محاسبه میانگین تأخیر:
  ```promql
  sum(rate(http_request_latency_seconds_sum[5m])) / sum(rate(http_request_latency_seconds_count[5m]))
  ```


## 4. متریک‌های Histogram

### تعریف و کاربرد
متریک‌های **Histogram** مشابه Summary هستند، زیرا توزیع مقادیر عددی را ردیابی می‌کنند. اما به‌جای محاسبه کوانتایل‌های از پیش تعیین‌شده، Histogram مقادیر را در **دسته‌های محدوده‌ای (Buckets)** شمارش می‌کند. این دسته‌ها نشان می‌دهند چه تعداد از مقادیر در هر محدوده (مثلاً درخواست‌های سریع، کند یا معمولی) قرار دارند.

### مثال ساده:
برگردیم به کافی‌شاپ. فرض کن می‌خوای بدونی مشتری‌ها چقدر منتظرن، اما به جای صدک، زمان انتظار رو تو دسته‌های زیر می‌شمری:

کمتر یا مساوی 1 دقیقه
کمتر یا مساوی 3 دقیقه
کمتر یا مساوی 5 دقیقه
کمتر یا مساوی 10 دقیقه

متریک Histogram بهت می‌گه چند تا مشتری تو هر کدوم از این دسته‌ها بودن. مثلاً:

10 نفر تا 1 دقیقه منتظر بودن.
50 نفر تا 3 دقیقه منتظر بودن.
90 نفر تا 5 دقیقه منتظر بودن.

### هیستوگرام‌های تجمعی (Cumulative Histograms)
در پرومتئوس، هیستوگرام‌ها به‌صورت **تجمعی** هستند، به این معنا که هر دسته شامل تعداد مقادیر تمام دسته‌های با محدوده پایین‌تر نیز می‌شود. این ویژگی باعث می‌شود که تعریف مرز بالایی هر دسته کافی باشد، زیرا هر دسته به‌طور ضمنی از صفر شروع می‌شود.

### ایجاد و تنظیم Histogram
هنگام ایجاد یک Histogram، باید مجموعه‌ای از محدوده‌های دسته‌ها (Bucket Ranges) را مشخص کنید. سپس، با استفاده از متد **Observe()**، مقادیر را ثبت می‌کنید. Histogram به‌طور خودکار شمارش دسته‌های مناسب را افزایش می‌دهد.

### فرمت نمایش (Exposition Format)
در فرمت نمایش، هر دسته Histogram به‌عنوان یک سری زمانی Counter با برچسب `le` (مخفف Less than or Equal) نمایش داده می‌شود. این برچسب نشان‌دهنده مرز بالایی دسته است. برای مثال:
- دسته‌ای با برچسب `le="0.2"` تعداد تمام درخواست‌هایی را نشان می‌دهد که کمتر یا مساوی 0.2 ثانیه طول کشیده‌اند.
- مشابه Summary، سری‌های زمانی `_count` و `_sum` نیز ارائه می‌شوند.

### انتخاب تعداد و محدوده دسته‌ها
انتخاب تعداد و محدوده دسته‌ها یک تعادل بین **دقت** و **هزینه** است:
- دسته‌های بیشتر و دقیق‌تر، وضوح بهتری ارائه می‌دهند، اما می‌توانند سرور پرومتئوس را تحت فشار قرار دهند.
- برای اطلاعات بیشتر در مورد استراتژی‌های انتخاب دسته‌ها، به مستندات پرومتئوس مراجعه کنید.

### کوئری‌نویسی با PromQL
می‌توانید هر دسته Histogram را به‌صورت جداگانه مانند یک Counter کوئری کنید. اما رایج‌ترین کاربرد، محاسبه کوانتایل‌های تقریبی با استفاده از تابع `histogram_quantile()` است. این تابع تنها تابع در PromQL است که برچسب‌های `le` را درک می‌کند. نکات مهم:
- معمولاً باید توابع `rate()` یا `increase()` را روی دسته‌های Histogram اعمال کنید تا داده‌ها را به یک بازه زمانی مشخص محدود کنید.
- هنگام تجمیع (مانند استفاده از عملگر `sum`)، باید برچسب `le` را حفظ کنید تا Histogram معتبر باقی بماند.

### مثال عملی
ردیابی تأخیر درخواست‌ها با Histogram در دسته های مختلف تعریف شده :
```python
from prometheus_client import Histogram
from flask import Flask
import time

app = Flask(__name__)
request_latency = Histogram('http_request_latency_seconds', 'HTTP request latency', buckets=[0.1, 0.2, 0.5, 1.0, 2.0])

@app.route('/')
def index():
    start = time.time()
    # شبیه‌سازی پردازش
    time.sleep(0.15)
    request_latency.observe(time.time() - start)
    return 'Request processed'
```

**تحلیل مثال**:
- دسته‌های `[0.1, 0.2, 0.5, 1.0, 2.0]` تأخیرهای تا 0.1، 0.2، 0.5، 1 و 2 ثانیه را شمارش می‌کنند.
- برای محاسبه کوانتایل 90 درصد در 5 دقیقه گذشته:
  ```promql
  histogram_quantile(0.9, sum(rate(http_request_latency_seconds_bucket[5m])))
  ```
- برای محاسبه میانگین تأخیر:
  ```promql
  sum(rate(http_request_latency_seconds_sum[5m])) / sum(rate(http_request_latency_seconds_count[5m]))
  ```

### محاسبه میانگین تأخیر
هم Summary و هم Histogram امکان محاسبه میانگین تأخیر درخواست‌ها را با استفاده از `_sum` و `_count` فراهم می‌کنند. این روش ارزان‌تر از تحلیل توزیع است و گاهی اوقات مفید خواهد بود.

## هیستوگرام‌های بومی (Native Histograms)
اخیراً نوع جدیدی از هیستوگرام‌ها به نام **Native Histograms** در پرومتئوس معرفی شده است که هنوز در مرحله آزمایشی قرار دارد. این نوع هیستوگرام امکان ذخیره یک هیستوگرام کامل را در یک نمونه سری زمانی به‌صورت کارآمد فراهم می‌کند. این ویژگی با تمام متریک‌های دیگر متفاوت است و در آینده جزئیات بیشتری در مورد آن ارائه خواهد شد.


## تفاوت کوئری‌های هیستوگرام و سامری در پرومتئوس

در این بخش، به زبان ساده تفاوت خروجی دو کوئری مربوط به متریک‌های **هیستوگرام** و **سامری** در پرومتئوس را توضیح می‌دهیم. با استفاده از مثال‌های روزمره، هدف این است که کاملاً واضح شود این دو کوئری چه اطلاعاتی به ما می‌دهند و چرا متفاوت هستند.

---

### 1. کوئری هیستوگرام
```promql
histogram_quantile(0.9, sum(rate(http_request_latency_seconds_bucket[5m])))
```

### این کوئری چه می‌کند؟
این کوئری **صدک 90** (90th Percentile) تأخیر درخواست‌های HTTP را برای **کل سیستم** (مثلاً همه سرورهای یک وبسایت) در 5 دقیقه گذشته محاسبه می‌کند.

- **چطور کار می‌کند؟**
  - متریک `http_request_latency_seconds_bucket` یک هیستوگرام است که زمان تأخیر درخواست‌ها را در دسته‌های مختلف (مانند کمتر از 0.1 ثانیه، 0.2 ثانیه و غیره) می‌شمارد.
  - `rate(...[5m])` نرخ افزایش هر دسته را در 5 دقیقه گذشته محاسبه می‌کند.
  - `sum(...)` داده‌های همه سرورها را جمع می‌کند تا یک هیستوگرام کلی بسازد.
  - `histogram_quantile(0.9, ...)` از این هیستوگرام کلی، صدک 90 را محاسبه می‌کند.

- **خروجی**: یک عدد (مثلاً 0.25 ثانیه) که نشان می‌دهد 90 درصد درخواست‌های HTTP در کل سیستم (همه سرورها) در 5 دقیقه گذشته کمتر یا مساوی این مقدار طول کشیده‌اند.

### به زبان ساده
فکر کن یک رستوران زنجیره‌ای با 5 شعبه داری. این کوئری مثل این است که بپرسی: «90 درصد مشتری‌های **همه شعبه‌ها** در 5 دقیقه گذشته حداکثر چقدر منتظر غذا بودند؟»  
مثلاً خروجی می‌گه: 90 درصد مشتری‌ها کمتر از 6 دقیقه منتظر بودند.  
**مثال وبسایت**: اگر وبسایتت 3 سرور داره، این کوئری می‌گه 90 درصد درخواست‌های HTTP در **همه سرورها** مثلاً کمتر از 0.25 ثانیه طول کشیده.

---

### 2. کوئری سامری
```promql
http_request_latency_seconds{quantile="0.9"}
```

### این کوئری چه می‌کند؟
این کوئری **صدک 90** تأخیر درخواست‌های HTTP را فقط برای **یک سرور خاص** نشان می‌دهد.

- **چطور کار می‌کند؟**
  - متریک `http_request_latency_seconds` یک سامری است که صدک‌های از پیش محاسبه‌شده (مثل 0.9) را ذخیره می‌کند.
  - `{quantile="0.9"}` فقط مقدار صدک 90 را برای یک سرور خاص انتخاب می‌کند.

- **خروجی**: یک عدد (مثلاً 0.3 ثانیه) که نشان می‌دهد 90 درصد درخواست‌های HTTP در **یک سرور خاص** کمتر یا مساوی این مقدار طول کشیده‌اند.

### به زبان ساده
حالا فکر کن فقط داری **یک شعبه خاص** از رستوران رو بررسی می‌کنی. این کوئری می‌پرسه: «90 درصد مشتری‌های این شعبه خاص چقدر منتظر غذا بودند؟»  
مثلاً خروجی می‌گه: 90 درصد مشتری‌های این شعبه کمتر از 5 دقیقه منتظر بودند.  
**مثال وبسایت**: این کوئری می‌گه 90 درصد درخواست‌های HTTP در **یک سرور خاص** مثلاً کمتر از 0.3 ثانیه طول کشیده.

---

### تفاوت به زبان ساده
- **هیستوگرام**:
  - به **کل سیستم** (همه سرورها یا شعبه‌ها) نگاه می‌کنه.
  - می‌گه: «90 درصد کل درخواست‌ها در همه سرورها چقدر طول کشیده؟»
  - مثل بررسی عملکرد کل رستوران زنجیره‌ای با همه شعبه‌هاش.
  - **کاربرد**: وقتی می‌خوای عملکرد کلی سیستم رو ببینی.

- **سامری**:
  - فقط به **یک سرور خاص** (یک شعبه) نگاه می‌کنه.
  - می‌گه: «90 درصد درخواست‌های این سرور خاص چقدر طول کشیده؟»
  - مثل بررسی فقط یک شعبه از رستوران.
  - **کاربرد**: وقتی فقط عملکرد یک سرور یا منبع خاص برات مهمه.
  - نمی‌تونی صدک‌های چند سرور رو با هم ترکیب کنی یا جمع بزنی (مثلاً نمی‌تونی صدک 90 از 3 سرور رو میانگین بگیری، چون از نظر آماری غلطه).

---

### چرا از هیستوگرام استفاده می‌کنیم وقتی سامری داریم؟

سامری برای وقتی خوبه که فقط می‌خوای یه سرور خاص رو بررسی کنی و نیازی به ترکیب داده‌های چند سرور نداری. مثلاً اگه فقط یه سرور داری یا فقط می‌خوای عملکرد یه سرور خاص رو ببینی، سامری سریع و ساده‌ست.

#### هیستوگرام برای وقتی بهتره که:
- چند سرور داری و می‌خوای عملکرد کل سیستم رو ببینی.
- می‌خوای صدک‌های مختلف (مثلاً 90، 95، 99) رو بعداً حساب کنی یا تحلیل‌های پیچیده‌تر انجام بدی.
- می‌خوای داده‌ها رو با روش‌های مختلف تجمیع کنی (مثلاً جمع کردن داده‌های چند سرور یا چند نوع درخواست).

#### مثال رستوران:

- اگه فقط بخوای بدونی مشتری‌های یه شعبه رستوران چقدر منتظرن، از سامری استفاده می‌کنی.
- اگه بخوای بدونی مشتری‌های همه شعبه‌ها چطورن یا مثلاً بخوای بعداً صدک 95 یا 99 رو حساب کنی، از هیستوگرام استفاده می‌کنی.

---

### مثال واقعی
فرض کن یه اپ مثل اسنپ داری:
- **هیستوگرام**: می‌گه 90 درصد سفرهای کل شهر (همه راننده‌ها) در 5 دقیقه گذشته مثلاً تو 10 دقیقه انجام شدن.
- **سامری**: می‌گه 90 درصد سفرهای یه راننده خاص تو همون 5 دقیقه مثلاً تو 8 دقیقه انجام شدن.

- 
### جمع‌بندی
در این بخش، چهار نوع متریک پرومتئوس (Gauge، Counter، Summary و Histogram) را به‌صورت عمیق بررسی کردیم. هر نوع متریک کاربرد خاص خود را دارد:
- ** نوع Gauge** برای مقادیر متغیر مانند دما یا استفاده از حافظه.
- ** نوع Counter** برای شمارش تجمعی رویدادها مانند تعداد درخواست‌ها.
- **نوع Summary** برای محاسبه کوانتایل‌های توزیع بدون نیاز به تجمیع.
- **نوع Histogram** برای تحلیل توزیع با امکان تجمیع و محاسبه کوانتایل‌های تقریبی.

درک این متریک‌ها و استفاده صحیح از آن‌ها در برنامه‌نویسی و کوئری‌نویسی با PromQL برای بهره‌برداری کامل از قابلیت‌های پرومتئوس ضروری است.

